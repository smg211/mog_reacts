function decode_react = DecodeReact(cfg, spike, kinematics, decode_reach)
% using the tuning profiles for decoding reaches generated by DecodeReach,
% decode the reach angles associated with candidate reactivation events
%
% Use as:
%       decode_react = DecodeReact(cfg, spike, kinematics, decode_reach)
%
%
% Sandon Griffin

% DECODER SETTINGS
lag_sel             = ft_getopt(cfg, 'lag_sel', 0);
nperms              = ft_getopt(cfg, 'nperms', 1000);
dorandperm          = ft_getopt(cfg, 'dorandperm', false);

cfg = updateCFG(cfg, who);

%% LOAD DATA
n_unit = length(spike);
n_class = length(decode_reach.class_info.cond_vals);

% Initialize output
decode_react = [];
decode_react.cfg = cfg;

%% IDENTIFY CANDIDATE EVENTS
% GET THE Z-SCORED GFR
% Get the train raster
[n_spk_all, t_all] = make_raster_stride(spike, 0.001, 0.001);

% Smooth the raster for each unit
smooth_sd = 5; % ms
n_spk_all_sm = smoother(n_spk_all, smooth_sd, 1);

% z-score each units firing rate with respect to break average and sd
cfg_toi = [];
cfg_toi.kinematics = kinematics;
is_toi = get_is_epoch(cfg_toi, t_all, 'break');
is_not_toi = get_is_epoch(cfg_toi, t_all, 'brkmove');

n_spk_brk_avg = nanmean(n_spk_all_sm(:, is_toi & ~is_not_toi), 2);
n_spk_brk_sd = nanstd(n_spk_all_sm(:, is_toi & ~is_not_toi), 0, 2);
n_spk_brk_z = (n_spk_all_sm - n_spk_brk_avg)./n_spk_brk_sd;

% get the average break z-scored FR
gfr_brk_z = nanmean(n_spk_brk_z, 1);

% DETECT GFR BURST EVENTS
gfr_signal = gfr_brk_z;
gfr_signal(~is_toi | is_not_toi) = nan;

gfr_med = median(gfr_signal, 'omitnan');
gfr_sd = nanstd(gfr_signal);

signal_thresh_sd = 2;
sig_thresh = gfr_med+signal_thresh_sd*gfr_sd;
nz_thresh = gfr_med;

cfg_fbs = cfg;
cfg_fbs.signal_thresh = sig_thresh;
cfg_fbs.noise_thresh = nz_thresh;
cfg_fbs.min_upstate_dur = 10; % ms
cfg_fbs.min_downstate_dur = 10; % ms

isburst = find_binary_state(cfg_fbs, gfr_signal);

% Get the start and end time of each burst
i_burst_start = find(diff([0 isburst]) == 1);
i_burst_end = find(diff([isburst 0]) == -1);
t_burst_start = t_all(i_burst_start);
t_burst_end = t_all(i_burst_end);

%% GET THE TUNING PROFILES AND RASTER USED FOR REACH DECODING
fxmatrix = decode_reach.fxmatrix;
[~, i_lag_sel] = min(abs((decode_reach.cfg.t_shift - lag_sel)));
fxmatrix = squeeze(fxmatrix(i_lag_sel, :, :));
class_vals = decode_reach.class_info.cond_vals;

% store output
decode_react.fxmatrix = fxmatrix;
decode_react.class_vals = class_vals;

%% GET THE SPIKE RASTER
% Create a spike count matrix of the entire recording period
binsize = 0.02; % sec
stride = 0.02; % sec
[n_spk_replay, t_replay] = make_raster_stride(spike, binsize, stride);

% get index of bins in the raster where candidate events occur
cfg_toi = [];
cfg_toi.kinematics = kinematics;
is_brk = get_is_epoch(cfg_toi, t_replay, 'break');
is_brkmv = get_is_epoch(cfg_toi, t_replay, 'brkmove');

t_brk = t_replay(is_brk & ~is_brkmv);

i_cand = [];
for t = 1:length(t_brk)
  if any(t_brk(t) >= t_burst_start & t_brk(t) <= t_burst_end)
    i_cand(end+1) = t;
  end
end

n_cand = length(i_cand);
t_cand = t_brk(i_cand);

% store output
decode_react.t_test = t_brk;
decode_react.i_cand = i_cand;
decode_react.t_cand = t_cand;

%% DETERMINE VELOCITY DIRECTION ESTIMATE AT EACH POINT IN THE RASTER
[p_cond_pred, cond_pred_ix] = do_bayes_decode(fxmatrix, ...
  n_spk_replay, binsize);

% store output
decode_react.p_cond_pred = p_cond_pred;
decode_react.cond_pred_ix = cond_pred_ix;

%% DETERMINE CORRELATION BETWEEN THE TUNING PROFILE AND ACTIVITY DURING THIS
% EVENT
% at each of the times associated with reactivations, determine whether the
% activity at that time correlates with the tuning profile for the most
% likely direction at a chance that is above expected based on permutation
% testing
pred_ix_react = cond_pred_ix(i_cand);
n_spk_react = n_spk_replay(:, i_cand);

rho_match = nan(1, n_cand);
for r = 1:n_cand
  rho_match(r) = corr(n_spk_react(:, r), fxmatrix(:, pred_ix_react(r)));
end

% get the order of units for each permutation
rp_order = nan(n_unit, nperms);
n_spk_react_rp = nan(n_unit, n_cand, nperms);
for n = 1:nperms
  rp_order(:, n) = randperm(n_unit);
  n_spk_react_rp(:, :, n) = n_spk_react(rp_order(:, n), :);
end

% get the correlations of the random permutations
rho_match_rp = nan(n_cand, nperms);
for r = 1:n_cand
  rho_match_rp(r, :) = corr(squeeze(n_spk_react_rp(:, r, :)), fxmatrix(:, pred_ix_react(r)));
end

% get the monte-carlo p value of associated with the correlation for each event
p_match_rp = sum(rho_match_rp > rho_match', 2)./nperms;

% DETERMINE THE REACTIVATION RATE FOR EACH DIRECTION, EACH BREAK
rr_dir_brk = get_reactrate(kinematics, n_class, t_cand, pred_ix_react, p_match_rp);

% store output
decode_react.pred_ix_react = pred_ix_react;
decode_react.rho_match = rho_match;
decode_react.p_match_rp = p_match_rp;
decode_react.rate_dir_brk = rr_dir_brk;

%% DETERMINE THE REACTIVATION RATE FOR SHUFFLED PERMUTATIONS
% this essentially proceeds the same as above except now we are treating
% the permutations that were generated to get the monte-carlo p values for
% each reactivation as the "true" reactivations for each permutation. This
% has the same effect as reshuffling units at all time bins and
% re-detecting reactivations, except this way will save much more time.
if dorandperm
  rr_dir_brk_rp = nan(nperms, n_class, length(kinematics.break));
  p_cond_pred_rp = nan(nperms, n_class, n_cand);
  cond_pred_ix_rp = nan(nperms, n_cand);
  rho_match_rp_rp = nan(nperms, n_cand, nperms);
  p_match_rp_rp = nan(nperms, n_cand);
  for n = 1:nperms
    % predict the direction associated with each permuted candidate event
    [p_cond_pred_rp(n, :, :), cond_pred_ix_rp(n, :)] = tc_bayes_decode(fxmatrix, ...
      squeeze(n_spk_react_rp(:, :, n)), binsize);
    pred_ix_react_rp = cond_pred_ix_rp(n, :);
    
    for r = 1:n_cand
      rho_match_rp_rp(n, r, :) = corr(squeeze(n_spk_react_rp(:, r, :)), fxmatrix(:, cond_pred_ix_rp(n, r)));
    end
    
    p_match_rp_rp(n, :) = sum(squeeze(rho_match_rp_rp(n, :, :)) > squeeze(rho_match_rp_rp(n, :, n))', 2)./nperms;
    
    rr_dir_brk_rp(n, :, :) = get_reactrate(kinematics, n_class, t_cand, pred_ix_react_rp, squeeze(p_match_rp_rp(n, :))');
  end
  
  % store output
  decode_react.cond_pred_ix_rp = cond_pred_ix_rp;
  decode_react.rho_match_rp_rp = rho_match_rp_rp;
  decode_react.p_match_rp_rp = p_match_rp_rp;
  decode_react.rr_dir_brk_rp = rr_dir_brk_rp;
end



%% SUBFUNCTIONS
function rr_dir_brk = get_reactrate(kinematics, n_class, t_cand, pred_ix_react, p_match_rp)

cfg_toi = [];
cfg_toi.kinematics = kinematics;

rr_dir_brk = nan(n_class, length(kinematics.break));
for k = 1:length(kinematics.break)
  dur_mv = sum(kinematics.break(k).t_move_end - kinematics.break(k).t_move_start);
  dur_tot = kinematics.break(k).t_end - kinematics.break(k).t_start;
  dur_nomv = dur_tot - dur_mv;

  is_brk = get_is_epoch(cfg_toi, t_cand, ['break' num2str(k)]);
  for d = 1:n_class
    is_dir = pred_ix_react == d;
    is_sig = p_match_rp < 0.01;
    n_react_dir = sum(is_brk & is_dir & is_sig');
    rr_dir_brk(d, k) = n_react_dir/dur_nomv;
  end
end








